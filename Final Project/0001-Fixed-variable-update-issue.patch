From cad09e6b6c7214a2bc345aab32e664260e7a05bb Mon Sep 17 00:00:00 2001
From: Sed458 <sed458@nyu.edu>
Date: Wed, 17 Apr 2019 13:19:09 -0400
Subject: [PATCH] Fixed variable update issue

---
 .DS_Store                                  | Bin 0 -> 6148 bytes
 0001-Implement-scheduling-algorithms.patch | 563 +++++++++++++++++++++
 xv6-public                                 |   1 +
 xv6/proc.c                                 |  35 +-
 4 files changed, 586 insertions(+), 13 deletions(-)
 create mode 100644 .DS_Store
 create mode 100644 0001-Implement-scheduling-algorithms.patch
 create mode 160000 xv6-public

diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000000000000000000000000000000000000..5008ddfcf53c02e82d7eee2e57c38e5672ef89f6
GIT binary patch
literal 6148
zcmeH~Jr2S!425mzP>H1@V-^m;4Wg<&0T*E43hX&L&p$$qDprKhvt+--jT7}7np#A3
zem<@ulZcFPQ@L2!n>{z**<q8>++&mCkOWA81W14cNZ<zv;LbK1Poaz?KmsK2CSc!(
z0ynLxE!0092;Krf2c+FF_Fe*7ECH>lEfg7;MkzE(HCqgga^y>{tEnwC%0;vJ&^%eQ
zLs35+`xjp>T0<F0fCPF1$Cyrb|F7^5{eNG?83~ZUUlGt@xh*qZDeu<Z%US-OSsOPv
j)R!Z4KLME7ReXlK;d!wEw5GODWMKRea10D2@KpjYNUI8I

literal 0
HcmV?d00001

diff --git a/0001-Implement-scheduling-algorithms.patch b/0001-Implement-scheduling-algorithms.patch
new file mode 100644
index 0000000..8d23083
--- /dev/null
+++ b/0001-Implement-scheduling-algorithms.patch
@@ -0,0 +1,563 @@
+From 888b804b715dc2dd157dc83da4449cc1891078cf Mon Sep 17 00:00:00 2001
+From: Sophia Danielsen <sed458@Nyu.edu>
+Date: Sat, 13 Apr 2019 23:38:54 -0400
+Subject: [PATCH] Implement scheduling algorithms
+
+---
+ xv6/Makefile  |  10 +++-
+ xv6/defs.h    |   2 +
+ xv6/param.h   |   2 +-
+ xv6/proc.c    | 140 ++++++++++++++++++++++++++++++++++++++++++++++----
+ xv6/proc.h    |   8 ++-
+ xv6/sanity.c  |  50 ++++++++++++++++++
+ xv6/syscall.c |   4 +-
+ xv6/syscall.h |   1 +
+ xv6/sysproc.c |  28 +++++++++-
+ xv6/trap.c    |   9 ++--
+ xv6/user.h    |   1 +
+ xv6/usys.S    |   1 +
+ 12 files changed, 236 insertions(+), 20 deletions(-)
+ create mode 100644 xv6/sanity.c
+
+diff --git a/xv6/Makefile b/xv6/Makefile
+index 67d76a1..8d6fb03 100644
+--- a/xv6/Makefile
++++ b/xv6/Makefile
+@@ -32,7 +32,7 @@ OBJS = \
+ # TOOLPREFIX = i386-jos-elf
+ 
+ # Using native tools (e.g., on X86 Linux)
+-#TOOLPREFIX = 
++#TOOLPREFIX =
+ 
+ # Try to infer the correct TOOLPREFIX if not set
+ ifndef TOOLPREFIX
+@@ -69,6 +69,10 @@ QEMU = $(shell if which qemu > /dev/null; \
+ 	echo "***" 1>&2; exit 1)
+ endif
+ 
++ifndef SCHEDFLAG
++SCHEDFLAG := DEFAULT
++endif
++
+ CC = $(TOOLPREFIX)gcc
+ AS = $(TOOLPREFIX)gas
+ LD = $(TOOLPREFIX)ld
+@@ -77,6 +81,7 @@ OBJDUMP = $(TOOLPREFIX)objdump
+ #CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer
+ CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -fvar-tracking -fvar-tracking-assignments -O0 -g -Wall -MD -gdwarf-2 -m32 -Werror -fno-omit-frame-pointer
+ CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++CFLAGS += -D $(SCHEDFLAG)
+ ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
+ # FreeBSD ld wants ``elf_i386_fbsd''
+ LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null)
+@@ -172,13 +177,14 @@ UPROGS=\
+ 	_usertests\
+ 	_wc\
+ 	_zombie\
++	_sanity\
+ 
+ fs.img: mkfs README $(UPROGS)
+ 	./mkfs fs.img README $(UPROGS)
+ 
+ -include *.d
+ 
+-clean: 
++clean:
+ 	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+ 	*.o *.d *.asm *.sym vectors.S bootblock entryother \
+ 	initcode initcode.out kernel xv6.img fs.img kernelmemfs mkfs \
+diff --git a/xv6/defs.h b/xv6/defs.h
+index 43431e3..fc75c99 100644
+--- a/xv6/defs.h
++++ b/xv6/defs.h
+@@ -116,6 +116,8 @@ void            sched(void);
+ void            sleep(void*, struct spinlock*);
+ void            userinit(void);
+ int             wait(void);
++int             wait_stat(int*, int*, int*, int*);
++void            update(void);
+ void            wakeup(void*);
+ void            yield(void);
+ 
+diff --git a/xv6/param.h b/xv6/param.h
+index 8e007ca..7febf8a 100644
+--- a/xv6/param.h
++++ b/xv6/param.h
+@@ -10,4 +10,4 @@
+ #define MAXOPBLOCKS  10  // max # of blocks any FS op writes
+ #define LOGSIZE      (MAXOPBLOCKS*3)  // max data sectors in on-disk log
+ #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
+-
++#define QUANTA        5   //setting the QUANTA to 5
+diff --git a/xv6/proc.c b/xv6/proc.c
+index a642f5a..83b2593 100644
+--- a/xv6/proc.c
++++ b/xv6/proc.c
+@@ -49,17 +49,23 @@ found:
+   p->pid = nextpid++;
+   release(&ptable.lock);
+ 
++  //Update new proc.h variables
++  p->ctime = ticks;
++  p->retime = 0;
++  p->rutime = 0;
++  p->stime = 0;
++
+   // Allocate kernel stack.
+   if((p->kstack = kalloc()) == 0){
+     p->state = UNUSED;
+     return 0;
+   }
+   sp = p->kstack + KSTACKSIZE;
+-  
++
+   // Leave room for trap frame.
+   sp -= sizeof *p->tf;
+   p->tf = (struct trapframe*)sp;
+-  
++
+   // Set up new context to start executing at forkret,
+   // which returns to trapret.
+   sp -= 4;
+@@ -80,13 +86,14 @@ userinit(void)
+ {
+   struct proc *p;
+   extern char _binary_initcode_start[], _binary_initcode_size[];
+-  
++
+   p = allocproc();
+   initproc = p;
+   if((p->pgdir = setupkvm()) == 0)
+     panic("userinit: out of memory?");
+   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+   p->sz = PGSIZE;
++  p->ctime = ticks;     //update proc ctime
+   memset(p->tf, 0, sizeof(*p->tf));
+   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+@@ -108,7 +115,7 @@ int
+ growproc(int n)
+ {
+   uint sz;
+-  
++
+   sz = proc->sz;
+   if(n > 0){
+     if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+@@ -155,14 +162,14 @@ fork(void)
+   np->cwd = idup(proc->cwd);
+ 
+   safestrcpy(np->name, proc->name, sizeof(proc->name));
+- 
++
+   pid = np->pid;
+ 
+   // lock to force the compiler to emit the np->state write last.
+   acquire(&ptable.lock);
+   np->state = RUNNABLE;
+   release(&ptable.lock);
+-  
++
+   return pid;
+ }
+ 
+@@ -254,6 +261,77 @@ wait(void)
+   }
+ }
+ 
++//wtime = wait time (able to run but no CPU access), rtime = run time, and iotime = waiting for io
++int wait_stat(int *wtime, int *rtime, int *iotime, int* status){
++  struct proc *p;
++  int havekids, pid;
++
++  acquire(&ptable.lock);
++  for(;;){
++    // Scan through table looking for zombie children.
++    havekids = 0;
++    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      if(p->parent != proc)
++        continue;
++      havekids = 1;
++      if(p->state == ZOMBIE){
++        int tatime = p->ttime - p->ctime;   //Turnaround Time
++        *wtime = tatime - p->rutime;
++        *rtime = p->rutime;
++        *iotime = p->stime;
++
++        // Found one.
++        pid = p->pid;
++        kfree(p->kstack);
++        p->kstack = 0;
++        freevm(p->pgdir);
++        p->state = UNUSED;
++        p->pid = 0;
++        p->parent = 0;
++        p->name[0] = 0;
++        p->killed = 0;
++        release(&ptable.lock);
++        *status = pid;
++        return pid;
++      }
++    }
++
++    // No point waiting if we don't have any children.
++    if(!havekids || proc->killed){
++      release(&ptable.lock);
++      *status = -1;
++      return -1;
++    }
++
++    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
++    sleep(proc, &ptable.lock);  //DOC: wait-sleep
++  }
++}
++
++//updating new proc.h vairables every clock tick
++void update(void){
++  struct proc *p;
++
++  acquire(&ptable.lock);
++
++  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++    switch(p->state){
++      case SLEEPING:
++        p->stime++;
++        break;
++      case RUNNABLE:
++        p->retime++;
++        break;
++      case RUNNING:
++        p->rutime++;
++        break;
++      default:
++        ;
++    }
++  }
++  release(&ptable.lock);
++}
++
+ //PAGEBREAK: 42
+ // Per-CPU process scheduler.
+ // Each CPU calls scheduler() after setting itself up.
+@@ -274,9 +352,53 @@ scheduler(void)
+     // Loop over process table looking for process to run.
+     acquire(&ptable.lock);
+     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
++      #ifdef DEFAULT                //Default Roumd Robin
++        if(p->state != RUNNABLE)
++          continue;
++      #endif
++
++      #ifdef FRR                    //First In First Our Round Robin
++      struct proc frrProc = NULL;
++
+       if(p->state != RUNNABLE)
+         continue;
+ 
++      for(newp = ptable.proc; newp < &ptable.proc[NPROC]; newp++){
++        if(frrProc == NULL){
++          frrProc = newp;
++        }
++        else{
++          if((p->ctime + p->stime + p->retime + p->rutime) < (frrProc->ctime+ frrProc->stime + frrProc->retime + frrProc->rutime)){
++            frrProc = newp;
++          }
++        }
++
++    if(p->state == RUNNABLE && frrProc != NULL){
++      p = frrProc;
++    }
++      #endif
++
++      #ifdef FCFS
++        struct proc firstProc = NULL;
++
++        if(p->state != RUNNABLE)
++          continue;
++
++        for(newp = ptable.proc; newp < &ptable.proc[NPROC]; newp++){
++          if(firstProc == NULL){
++            firstProc = newp;
++          }
++          else{
++            if(p->ctime < firstProc->ctime){
++              firstProc = newp;
++            }
++          }
++
++      if(p->state == RUNNABLE && firstProc != NULL){
++        p = firstProc;
++      }
++      #endif
++
+       // Switch to chosen process.  It is the process's job
+       // to release ptable.lock and then reacquire it
+       // before jumping back to us.
+@@ -336,12 +458,12 @@ forkret(void)
+ 
+   if (first) {
+     // Some initialization functions must be run in the context
+-    // of a regular process (e.g., they call sleep), and thus cannot 
++    // of a regular process (e.g., they call sleep), and thus cannot
+     // be run from main().
+     first = 0;
+     initlog();
+   }
+-  
++
+   // Return to "caller", actually trapret (see allocproc).
+ }
+ 
+@@ -446,7 +568,7 @@ procdump(void)
+   struct proc *p;
+   char *state;
+   uint pc[10];
+-  
++
+   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+     if(p->state == UNUSED)
+       continue;
+diff --git a/xv6/proc.h b/xv6/proc.h
+index 3b9c3ac..376591b 100644
+--- a/xv6/proc.h
++++ b/xv6/proc.h
+@@ -10,7 +10,7 @@ struct cpu {
+   volatile uint started;       // Has the CPU started?
+   int ncli;                    // Depth of pushcli nesting.
+   int intena;                  // Were interrupts enabled before pushcli?
+-  
++
+   // Cpu-local storage variables; see below
+   struct cpu *cpu;
+   struct proc *proc;           // The currently-running process.
+@@ -66,6 +66,12 @@ struct proc {
+   struct file *ofile[NOFILE];  // Open files
+   struct inode *cwd;           // Current directory
+   char name[16];               // Process name (debugging)
++
++  int ctime;                   //Creation time
++  int ttime;                   //Termination time
++  int stime;                   //Sleeping time
++  int retime;                  //Ready time
++  int rutime;                  //Running time
+ };
+ 
+ // Process memory is laid out contiguously, low addresses first:
+diff --git a/xv6/sanity.c b/xv6/sanity.c
+new file mode 100644
+index 0000000..589093c
+--- /dev/null
++++ b/xv6/sanity.c
+@@ -0,0 +1,50 @@
++#include "types.h"
++#include "user.h"
++
++
++int main(int argc, char *argv[]) {
++  int i;
++  int j;
++  int pid;
++  int retime; //waiting time
++  int rutime; //running time
++  int stime;  //sleeping time
++  int tatime; //turnaround time
++  int count;
++
++  for(i = 0; i < 20; i++){
++    //fork 20 child processes
++    pid = fork();
++    count = 0;
++
++    //child process
++    if(pid == 0){
++      for(j = 0; j <10000000; j++){
++        count = 1000*4 + 21;
++        count++;
++      }
++      exit();
++    }
++    continue;
++  }
++
++  int avgReTime = 0;
++  int avgRuTime = 0;
++  int avgTaTime = 0;
++  //print information
++  for(i = 0; i < 20; i++){
++    wait_stat(&retime, &rutime, &stime, &pid);
++    retime = retime * -1;
++    tatime = rutime + retime;
++
++    avgReTime += retime;
++    avgRuTime += rutime;
++    avgTaTime += tatime;
++
++    printf(1, "Waiting Time: %d, Running Time: %d, Turnaround Time: %d\n", retime, rutime, tatime, stime, pid);
++  }
++
++  printf(1, "Average Waiting: %d, Average Running: %d, Average Turnaround: %d\n", avgReTime/20, avgRuTime/20, avgTaTime/20);
++
++  exit();
++}
+diff --git a/xv6/syscall.c b/xv6/syscall.c
+index 799ebc2..3579347 100644
+--- a/xv6/syscall.c
++++ b/xv6/syscall.c
+@@ -55,7 +55,7 @@ int
+ argptr(int n, char **pp, int size)
+ {
+   int i;
+-  
++
+   if(argint(n, &i) < 0)
+     return -1;
+   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+@@ -96,6 +96,7 @@ extern int sys_sbrk(void);
+ extern int sys_sleep(void);
+ extern int sys_unlink(void);
+ extern int sys_wait(void);
++extern int sys_wait_stat(void);     //added wait_stat system call
+ extern int sys_write(void);
+ extern int sys_uptime(void);
+ 
+@@ -121,6 +122,7 @@ static int (*syscalls[])(void) = {
+ [SYS_link]    sys_link,
+ [SYS_mkdir]   sys_mkdir,
+ [SYS_close]   sys_close,
++[SYS_wait_stat] sys_wait_stat,         //added wait_stat system call
+ };
+ 
+ void
+diff --git a/xv6/syscall.h b/xv6/syscall.h
+index bc5f356..75afa5e 100644
+--- a/xv6/syscall.h
++++ b/xv6/syscall.h
+@@ -20,3 +20,4 @@
+ #define SYS_link   19
+ #define SYS_mkdir  20
+ #define SYS_close  21
++#define SYS_wait_stat 22          //added wait_stat system call
+diff --git a/xv6/sysproc.c b/xv6/sysproc.c
+index 027a5e5..22f4600 100644
+--- a/xv6/sysproc.c
++++ b/xv6/sysproc.c
+@@ -26,6 +26,30 @@ sys_wait(void)
+   return wait();
+ }
+ 
++int
++sys_wait_stat(void)
++{
++  int* retime;
++  int* rutime;
++  int* stime;
++  int* status;
++
++  if (argptr(0, (void*)&retime, sizeof(retime)) < 0){
++    return -1;
++  }
++  if (argptr(1, (void*)&rutime, sizeof(retime)) < 0){
++    return -1;
++  }
++  if (argptr(2, (void*)&stime, sizeof(stime)) < 0){
++    return -1;
++  }
++  if (argptr(3, (void*)&status, sizeof(status)) < 0){
++    return -1;
++  }
++
++  return wait_stat(retime, rutime, stime, status);
++}
++
+ int
+ sys_kill(void)
+ {
+@@ -61,7 +85,7 @@ sys_sleep(void)
+ {
+   int n;
+   uint ticks0;
+-  
++
+   if(argint(0, &n) < 0)
+     return -1;
+   acquire(&tickslock);
+@@ -83,7 +107,7 @@ int
+ sys_uptime(void)
+ {
+   uint xticks;
+-  
++
+   acquire(&tickslock);
+   xticks = ticks;
+   release(&tickslock);
+diff --git a/xv6/trap.c b/xv6/trap.c
+index 3f80145..f501faf 100644
+--- a/xv6/trap.c
++++ b/xv6/trap.c
+@@ -22,7 +22,7 @@ tvinit(void)
+   for(i = 0; i < 256; i++)
+     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
+   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
+-  
++
+   initlock(&tickslock, "time");
+ }
+ 
+@@ -51,6 +51,7 @@ trap(struct trapframe *tf)
+     if(cpu->id == 0){
+       acquire(&tickslock);
+       ticks++;
++      update();       //update new proc.h variables every clock tick
+       wakeup(&ticks);
+       release(&tickslock);
+     }
+@@ -77,7 +78,7 @@ trap(struct trapframe *tf)
+             cpu->id, tf->cs, tf->eip);
+     lapiceoi();
+     break;
+-   
++
+   //PAGEBREAK: 13
+   default:
+     if(proc == 0 || (tf->cs&3) == 0){
+@@ -89,13 +90,13 @@ trap(struct trapframe *tf)
+     // In user space, assume process misbehaved.
+     cprintf("pid %d %s: trap %d err %d on cpu %d "
+             "eip 0x%x addr 0x%x--kill proc\n",
+-            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip, 
++            proc->pid, proc->name, tf->trapno, tf->err, cpu->id, tf->eip,
+             rcr2());
+     proc->killed = 1;
+   }
+ 
+   // Force process exit if it has been killed and is in user space.
+-  // (If it is still executing in the kernel, let it keep running 
++  // (If it is still executing in the kernel, let it keep running
+   // until it gets to the regular system call return.)
+   if(proc && proc->killed && (tf->cs&3) == DPL_USER)
+     exit();
+diff --git a/xv6/user.h b/xv6/user.h
+index f45b8d5..2bdc8c9 100644
+--- a/xv6/user.h
++++ b/xv6/user.h
+@@ -23,6 +23,7 @@ int getpid(void);
+ char* sbrk(int);
+ int sleep(int);
+ int uptime(void);
++int wait_stat(int*, int*, int*, int*);   //added wait_stat system call
+ 
+ // ulib.c
+ int stat(char*, struct stat*);
+diff --git a/xv6/usys.S b/xv6/usys.S
+index 8bfd8a1..81e0f9b 100644
+--- a/xv6/usys.S
++++ b/xv6/usys.S
+@@ -29,3 +29,4 @@ SYSCALL(getpid)
+ SYSCALL(sbrk)
+ SYSCALL(sleep)
+ SYSCALL(uptime)
++SYSCALL(wait_stat)    //added wait_stat system call
+-- 
+2.20.1 (Apple Git-117)
+
diff --git a/xv6-public b/xv6-public
new file mode 160000
index 0000000..6c1496f
--- /dev/null
+++ b/xv6-public
@@ -0,0 +1 @@
+Subproject commit 6c1496f37e7a3445ccfa050c6c5374c3839e5aec
diff --git a/xv6/proc.c b/xv6/proc.c
index 83b2593..6118232 100644
--- a/xv6/proc.c
+++ b/xv6/proc.c
@@ -358,47 +358,56 @@ scheduler(void)
       #endif
 
       #ifdef FRR                    //First In First Our Round Robin
-      struct proc frrProc = NULL;
+      struct proc *frrProc;
+      struct proc *newp;
+        
+      int start = 0;
 
       if(p->state != RUNNABLE)
         continue;
 
       for(newp = ptable.proc; newp < &ptable.proc[NPROC]; newp++){
-        if(frrProc == NULL){
+        if(start == 0){
           frrProc = newp;
+          start = 1;
         }
         else{
-          if((p->ctime + p->stime + p->retime + p->rutime) < (frrProc->ctime+ frrProc->stime + frrProc->retime + frrProc->rutime)){
+          if((newp->ctime + newp->stime + newp->retime + newp->rutime) < (frrProc->ctime+ frrProc->stime + frrProc->retime + frrProc->rutime)){
             frrProc = newp;
           }
         }
+      }
 
-    if(p->state == RUNNABLE && frrProc != NULL){
-      p = frrProc;
-    }
+      if(p->state == RUNNABLE && start != 0){
+        p = frrProc;
+      }
       #endif
 
       #ifdef FCFS
-        struct proc firstProc = NULL;
+        struct proc *firstProc;
+        struct proc *newp;
+        
+        int start = 0;
 
         if(p->state != RUNNABLE)
           continue;
 
         for(newp = ptable.proc; newp < &ptable.proc[NPROC]; newp++){
-          if(firstProc == NULL){
+          if(start == 0){
             firstProc = newp;
           }
           else{
-            if(p->ctime < firstProc->ctime){
+            if(newp->ctime < firstProc->ctime){
               firstProc = newp;
             }
           }
+        }
 
-      if(p->state == RUNNABLE && firstProc != NULL){
-        p = firstProc;
-      }
+        if(p->state == RUNNABLE && start != 0){
+          p = firstProc;
+        }
       #endif
-
+        
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
-- 
2.20.1 (Apple Git-117)

